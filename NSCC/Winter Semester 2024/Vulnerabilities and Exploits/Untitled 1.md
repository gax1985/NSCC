


>[!note]
>
>The **Internet Protocol** is like a truck. We have one protocol carrying something from another protocol to the network with *encapsulation*




## Wireless Protocol 



When attempting to login into a WIFI network, generally the network will have a **Passphrase** to successfully connect to the network


Ron had multiple occassions where a public WIFI network for a corporation was not configured correctly.


It is a doorway unto the network. This became critical during the pandemic, due to people being sent home without much preparation.  This means that a lot of organizations had extra risk. 


Routers tend to have a combination of letters and numbers by default as a default password. Some people change it to a weaker password (The original password may be randomly generated and may contain numbers and letters)


If you go to a large hotel, the web traffic is being pushed through the hotel's proxy, and sometimes ads are added. 


Fundamentally, it is simple to hack WIFI because people do dumb things such as a *weak password*




# Wireless Hacking 




There is a difference between adequate WIFI setup (third party verification, proper authentication ) and others which are misconfigured ( such as businesses letting employees access the corporate network with a WIFI password)


### Evil Twin Attacks

A lot of businesses or public WIFI networks are prone to someone injecting themselves to act as a midpoint between the corporate devices and the actual server


On the free WIFI network, one should never trust public WIFI networks, **Airports are prone to the  *Evil Twin Attack***


If you have been on a WIFI network before, and the device is set to auto connect, the device reconnects to it. Ron was in Nevada, and the phone was connected to their WIFI network. The device checks every WIFI connection we have ever had all the time. 


The only thing it needs to connect is the **SSID**, which is an alpha-numeric phrase


If Ron is sitting at the restaurant working on the restaurant's WIFI. When he leaves, someone can name the name of the network to the same name as the restaurant's network. If Ron worked within the range of the evil networrk, then the attacker can connect to Ron's device. 



>[!todo]
>
>
>If you would like to discover passhrases stored on the machine :
>
>	netsh wlan show profiles 
>
>	netsh wlan show profile <SSID> key=clear 
>	Then, we can check Security Key and Key Content


## Important Terms 

• SSID — Service Set ID, Alphanumeric name of your wireless network.
• BSSID — Basic Service Set ID, Hexademicimal number of the WAP mac
address
• IBSS — Independent Basic Service Set ID, randomly generated 48 bit
number used in place of a BSSID (MAC) on adhoc networks without
an AP.

>[!note]
>
>	To display: netsh wlan show interfaces



# WIFI AUthentication :



## 4 Way Handshake 



To encrytpt traffic between encrypted access point and the client : 


1. There is a **Pairwise Transit Key or PTK** for unicast traffic --> unique between client and Access point)
2. Group Temporal Key or GTK for multicast traffic ---> Shared by all clients of the Access Point




It is important to understand that PSK is **NEVER TRANSMITTED** between the access point and the device. It is something in advance that we know and the access point knows ( password)



#### 4-Way Handshake 


In order to come up with the Pre-shared key, the actual key is [produced by a recipe ]: 

1. SSID ( we know that. It is evidently broadcasted by the access point)
2. Passphrase 
3. Length of passphrase
4. Level of desired encryption
5. Hashing Algorithm (SHA1 in this case)

##### Terms :

Authenticator  --> Access Point 

Supplicant      ---> Supplicant 


Access Point has an A before it, making it distinctly known as the authenticator


The resulting dish is the hashi of these values


If we are working with a properly set up wWIFI netwrok ( additional authentication on top of the Passphrase), We would have a master Session key 
(it is ignored)




In order to encrypt your traffic, you need the Pairwise Transit Key ( PTK), which is the key to encrypt your traffic. We would need the Pairwise Master Key(PMK ) to calculate it. We would use a preshared key (in WPA2/PSK)  as the Pairwise Master Key (PSK/PMK
is never trnasmitted)




Each side generate a random number and sends it to the other side . The number broadcasted by the access point ( MAC ADDRESS + Anounce) , which is sent to the laptop. If we are in enterprise system, we would need a Pairwise Master Key. If we are going to someone's home network, we would use the Pre-shared key. 



Recipe for preshared key = SSID + Passphrase + Lentg of pass 







PTK = PRF ( PMK + Anounce + Snounce Mac Address of the AP + Mac Address of the Client)

PTK = PRF ( PSK + Anounce + Snounce + Mac address of the AP + Mac Address of the Client)




PRF = Function


Only thing missing is the passphrase. If we can get that, we can get the PTK which allows us to communicate on the network freely, 




Wireless has a broadcast function. The access point uses Group Master Key (same for everyone, and it allows broadcasting). 

GML is derived from the Master Session Key (MSK)

Master Session Key is created by the 802.1X/EAP or a Pre-Shared Key

MSK --> GMK -> GTK OR PSK->




Pairwise master key is generated by the master session key or the preshared key (and available on all devices).



Pairwise Transit Key : Encrypts unicast traffic. Access point generates Anounce, and client generates Snounce, Mac addrss of the client, Mac address of the Access POint
PTK = PTF(aka. Pseudo random function) (PMK + anounce + snounce + Mac Address of access point + mac address of client )



![[Pasted image 20240226141847.png]]



The access point knows the pairwoser master key 
It knows the Supplicant Mac address
It knows the access point mac address
Sends an Anounce to the client 
The client has Snounce already (generated at the beginning )
Creates Pairwise Transit Key and Access Point generates Group Transit Kkey. Each side generates their respective keys individually. 
It sends Group Tempo Key 
The client installs PTK, Installts GTK from the access point, and now it sends an acknowlkedgement to the access point. After all is wqell, it installs a Pairwise Transit Key. 


![[Pasted image 20240226142126.png]]





The message chat is EAPOL (- Protocol in TCP) (messages in this process )




## EAPOL


Extensible Authentication Protocol pver Lan (ether type 0x888E)




Suuplicant(client )- --> authenticatior (access point) ---> Authentication Server (RADIUS)


EAPOL is a basic encapsulation protocol. It is only used on the local looo.

Ether type tells you the embdeed protocol (ICMP, TCP etc ) in this case EAPol

We can do this hack wihtout knowing this. We can download scripts that woujld do this. Ron would like us to have a basic exposure to the protocol. We are encouraged to learn it as much as possible!

![[Pasted image 20240226142520.png]]



>[!todo]
>
>## Further Learning : 
>
>**https://ipcisco.com/lesson/eapol-extensible-authentication-protocol-over-lan/**



How do we decrypt this traffic? 


Passphrase is never shared. the hash of teh passphrase is. The passphrase is embedded in the PSK. We know everything else except for the passphrase. We need to capture the 4-way handshake when this encryption is set up. 

The handshake happens once when you authenticate to the access  point. The mroe samples we have of it, the better our chances are. 


How do we get multiple samples? You reconnect a large number of times to get multiple samples. You would use a DeAUTH (De-authentication packet) Packet, to disconnect the client. We would pretend to be the access point. The user does not see this. All the other clients reconnect again automatically. Every time it reconnects , we get a new sample. What the user sees is a spinning circle or a general slowdown. If you did not have autoconnection set up, you would see this! Once you set a wifi netwrok, usuall yyou do an autoconnect (which is helpful for us). We can figure out everything we need to come up with the Pairwise Transit Key ( Encryption key) except for the passphrase. the HASH IS SENT! The passphrase is never sent! If the passphrase is weak , we can guess it! 


If Bell provided a router, and the password is a long string of characters plastered on the router. We can crack tghe hash of a weak passphrase.

![[Pasted image 20240226143132.png]]



The only thing we Cannot see if the passphrase. the hash of the passphrase is embedded in the transmission. 


![[Pasted image 20240226143215.png]]


When traffic is sent by using ARP table and MAC addresses, because mac addresses are unique, the packet travels to every NIC, and if it is not intended for that machine, it passes it, and if it is intedned it picks it up. With permiscious mode, it  captures the traffuc onb the netwrok regardless of whether it was meant for us or not. This is also called 'Monitor Mode'. Ron will hand us WIFI dongles to complete the assignment. They are 35 dollars. 


![[Pasted image 20240226143428.png]]



We would use the special WIFI adapter, wherew would see all the access points, and the traffic between all the access points. Normally we are looking at one channel. We would excluse other access points talking to other clients. The WIFI card in monitor mode sees all of them. The traffic though is encrypted, but we can see it. 

Then , deauth to get samples of the handshake. Without the tool, the deauth packet would be built from scract

Then the password list (rockyou, goodguess)
 
Then a tool that does different hash combinations really fast (**Airgedden**, part of the Metasploit Framework)


![[Pasted image 20240226145158.png]]




# Proper WIFI AUthentication 



We will use a **RADIUS** server, which originally handled authentication for Dialup modems (56k). To make it more secure , RADIUS was created,. Through port fdorwarding, it takes the crerdentials, and send it off to the enterprise authentication system (Windows Kerberos Active Directory). so 


Access point ---> RADIUS Server --> Enterprise Network 



Microsoft has a RADIUS server 
Cisco has RADIUS servers

The differences would be in the interface. If we have RADIUS set up , we would have a secure wireless setup (aside from human error). 


The Master Session Key and others are coming from this ...

RADIUS server = AAA Authentication 


Most network administrators never heard of CBDs. 


Basic wireless authentication happens at the router, and after the recipe is cooked and done, it depends on the passphrase. Most people do not have a complex passphrase if you set it up yourself. 





# Levels of Authentication on WIFI


## WPA3 


It does NOT use the 4-way handshake as normal

The hack may not work on WPA3




## WIFI Hacking Video : 


![[Pasted image 20240226150324.png]]





BSSID = Mac Address of the Access Point


Data column tells you how much data is being transferred (where we would know that this is a promising network, which means people are connected to it and sending data)


![[Pasted image 20240226152034.png]]



It took samples of the handshake, and brute forced it to get the hash that matched to attain the passphrase


![[Pasted image 20240226152109.png]]




>[!danger]
>
>
>**Airgedden** is a VERY noisy attack!
>










# Future Assignment : 


We need : 

1. Phone
2. Laptop


We would do it in *pairs*!













----------------------------------------------




## Supplemental 4-Way Handshake Reading : 


# Details of Key Derivation for WPA

This section describes the message formats and exchanges that are used in establishing the key hierarchies. In particular, we show the frame format used for the EAPOL-Key frames used in the four-way and two-way exchanges. The details shown here apply specifically to WPA but are basically similar for IEEE 802.11i TKIP and AES as well.

Prior to the key exchanges and temporal key derivation, several things will already have occurred. The access point will have advertised its capabilities and a mobile device will have selected a security method, associated, and initiated an authentication exchange. If upper-layer authentication is in operation, an exchange between the supplicant and authentication server will have completed, resulting in the delivery of a PMK to the access point. The access point will have intercepted an EAP-Success message and delivered it to the supplicant. Receipt of EAP-Success by the access point triggers the four-way key exchange.

In WPA, the key exchange is done using a special variant of the EAPOL-Key message, which is different from that defined in IEEE 802.1X. This variant has some extra fields and is shown in Figure 10.7.

##### Figure 10.7. WPA Version of EAPOL-Key Descriptor

![graphics/10fig07.gif](https://etutorials.org/shared/images/tutorials/tutorial_113/10fig07.gif)

The descriptor shown in Figure 10.7 appears in the message body section of an EAPOL frame. In practice, it would be preceded by the EAPOL header, as appropriate for IEEE 802.11. The purpose of each field is described in Table 10.1. The most complicated field is Key Information, which is divided into a number of control bits and subfields. Understanding the contents of this field is essential to understanding how the handshake works. The Key Information field is a 16-bit value divided up as shown in Figure 10.8. and described in Table 10.2. The meaning of the control bits 5 through 9 is shown in Table 10.3.

##### Figure 10.8. Key Information Field

![graphics/10fig08.gif](https://etutorials.org/shared/images/tutorials/tutorial_113/10fig08.gif)

|   |   |
|---|---|
##### Table 10.1. Fields of the WPA EAPOL-Key Message
|Descriptor Type|Unique value (254) that identifies this descriptor as the WPA variant.|
|Key Information|This field contains several subfields that provide information about the key type and how it should be used. It also contains various control bits to assist in the handshake procedure.|
|Key Length|The length of the key in bytes. Note in the pairwise key this is the length of the PTK, even though the actual PTK is not sent in a key frame; it is the target key.|
|Replay Counter|This value is incremented with every message to detect any attempts at replaying an old message. The exception is when this message is in response to an ACK request, in which case the replay value of the message being "ACKed" is inserted.|
|Key Nonce|Nonce value used to derive temporal pairwise keys or group keys.|
|EAPOL-Key IV|For group key transfer, the GTK is encrypted using the EAPOL-Key Encryption key in conjunction with this IV value. The encrypted GTK is placed in the Key Data area.|
|Key Sequence Start|This indicates the value of the sequence number to be expected in the first frame received after the keys are installed. The sequence number protects against replay attacks.|
|Key Identifier|This is not used in WPA. In the future it might be used to enable multiple keys to be set up in advance.|
|Key MIC|This is an integrity check value computed across the entire EAPOL-Key frame from the EAPOL Protocol version field to the end of the key material (this field is set to 0 during the computation).|
|Key Data Length|Defines the length number of bytes in the Key Data field (which might be different from the actual key itself).|
|Key Data|Material that needs to be sent in secret. For example, in the case of the group key, this is the encrypted value of the GTK. In some pairwise key messages, this carries an information element.|

Show more

|   |   |
|---|---|
##### Table 10.2. Key Information Field Summary
|Bits 0?3|Currently unused and set to 0.|
|Bits 4?9|Control bits set at different stages of the handshake.|
|Bits 10?11|Indicate the key index in the case of group keys. This allows the keys to be updated late by installing new group keys at a different index position to the current operation group key.|
|Bit 12|Distinguishes between the pairwise and group key messages|
|Bits 13?15|Indicate the version and allow different schemes and key encryption methods to be used in the future. The value of 001 indicates that:<br><br>EAPOL MIC is calculated using HMAC-MD5<br><br>EAPOL key encryption is done using RC4|

Show more

|   |   |
|---|---|
##### Table 10.3. EAPOL-Key Message Control Bits
|Request|This bit is used by the supplicant to request that the authenticator initiate a new four-way handshake to refresh the keys.|
|Error|In TKIP (see Chapter 11), if a MIC failure is detected by a mobile device, a key message is sent with the Error bit set to inform the access point. The Request bit will also be set to request a rekey operation.|
|Secure|This is set when the four-way key exchange is completed to indicate that the link is now secure.|
|MIC|This bit is used to indicate when a MIC has been computed for this message and inserted into the MIC field.|
|ACK|This is set in messages from the authenticator to indicate that it expects a response from the supplicant.|
|Install|For pairwise keys, this bit indicates that the new key should be installed and put into effect. For group keys, this bit is 0.|

Show more

The Key Data field is used differently in pairwise and group key handshakes. You might expect that this field would be used to send the actual key to the other party encrypted using the EAPOL-Key Encryption key. This is true in the case of the GTK; however, the pairwise keys are computed independently by the supplicant and the authenticator and are not sent in the key message at all.

In the case of pairwise keys, the Key Data field is used for another purpose. It is used to send a copy of the WPA/RSN Information Element. Information elements in general are described in Chapter 5 and this element in particular is discussed further in Chapter 13. For the moment, just accept that the information element needs to be transferred and that the Key Data field is used for this purpose.

#### Four-Way Handshake

One of the best ways to understand use of the EAPOL-Key descriptor is to look at a practical example. In the following paragraphs, we follow a four-way handshake.

##### Message (A): Authenticator![](https://etutorials.org/shared/images/tutorials/tutorial_113/U2192.GIF)Supplicant

At the starting state, no keys are known so the MIC cannot be computed. The authenticator uses this message only to send its value of ANonce to the supplicant. The contents of message (A) are shown in Table 10.4.

|   |   |
|---|---|
##### Table 10.4. Message (A) Contents
|Descriptor type|254|
|Key Information|Request, Error: 0<br><br>Secure: 0<br><br>MIC: 0<br><br>Ack: 1<br><br>Install: 0<br><br>Index: 0<br><br>Key type: Pairwise<br><br>Descriptor type: 1|
|Key Length|64|
|Replay Counter|<current value>|
|Key Nonce|ANonce|
|EAP-Key IV|0|
|RSC|0|
|Key Identifier|0|
|Key MIC|0|
|Key Data Length|0|

Show more

- The Error bit is 0 because this is the first message.
    
- The Secure bit is 0 because the four-way handshake has not completed yet.
    
- There is no MIC so the MIC bit is 0.
    
- The authenticator requires the supplicant to send a reply so it sets the ACK bit. If no reply is received after a timeout, the authenticator may resend the message three times before giving up. However, the message should be resent as is, that is, with the same replay field so that, in case the supplicant did receive a previous message, it knows it is a duplicate and not a new message.
    
- We are not ready to install keys so Install is 0.
    
- The Index field is not used with pairwise keys.
    
- The Key Type field indicates "pairwise" and the Descriptor Type field is set to 1.
    
- The Replay Counter is the value of a counter that is set to 0 when the PMK is first established and is incremented between successive messages.
    
- The value of ANonce is passed in the Key Nonce field and all the other fields are set to 0. Note that the value of ANonce can't be any old nonce. It has to be selected in a particular way, as described later in this chapter.
    
- The value of EAP-Key IV is 0 because there is no key data.
    
- RSC is 0 because the keys are no yet ready for installation.
    
- Key identifier is reserved and always 0.
    

Message (A) is sent without any protection. It is not encrypted and there is no MIC. This is the only key message that is ever sent without the MIC bit set to 1?a fact that can be exploited by the supplicant, which should discard the message if any of the fixed fields are different from what has been described here. For example, if the supplicant sees the MIC bit as 0 but the Install bit set, it knows there is foul play.

Given that the supplicant checks the expected fields, an attacker is limited to modifying the Replay Counter or the ANonce fields. Changing the Replay Counter can only result in message rejection and so is pointless. Any changes to the ANonce value will be caught in message (B) because the temporal keys computed by the supplicant from the corrupted ANonce value would be invalid. In such a case message (B) would fail the MIC test and be discarded. Therefore, the fact that message (A) is unprotected does not compromise security.

##### Message (B): Supplicant![](https://etutorials.org/shared/images/tutorials/tutorial_113/U2192.GIF)Authenticator

After successful delivery of the first message, the supplicant has a copy of ANonce and generates it own value of SNonce. It is then able to compute the transient key. Next, it prepares to send message (B) to the authenticator. This message contains a MIC value and thus proves that the supplicant knows the PMK. The fields for message (B) are shown in Table 10.5.

|   |   |
|---|---|
##### Table 10.5. Message (B) Contents
|Descriptor type|254|
|Key Information|Request, Error: 0<br><br>Secure: 0<br><br>MIC: 1<br><br>Ack: 0<br><br>Install: 0<br><br>Index: 0<br><br>Key type: Pairwise<br><br>Descriptor type: 1|
|Key Length|64|
|Replay Counter|From rcvd Key Message|
|Key Nonce|SNonce|
|EAPOL-Key IV|0|
|RSC|0|
|Key Identifier|0|
|Key MIC|MIC Value|
|Key Data Length|Length of Key Data|
|Key Data|Information Element|

Show more

- The Error field is 0 because there was no MIC value on the previous frame (therefore MIC failure is impossible).
    
- The Secure field remains 0 until the end of the four-way handshake.
    
- The MIC field is 1 to indicate that a MIC value has been computed and attached to this message.
    
- This message is in response to the ACK bit, which was set in message (A). Therefore the ACK bit in this message is clear.
    
- Install is set to 0 because the keys are not agreed on yet.
    
- Index is not used.
    
- Key Type indicates pairwise.
    
- Descriptor type is 1.
    
- The Replay Counter in this message should be set to the same value as the counter sent in message (A). This is because it is a response to the ACK bit in message (A). Any other value should be rejected by the authenticator.
    
- The value of SNonce is sent in the Key Nonce field. This value is needed by the authenticator to compute its copy of the temporal keys.
    
- The MIC value is placed in the Key MIC position.
    
- This frame contains unencrypted Key Data. This is the information element that was used to negotiate the security parameters during the association phase. Inclusion of the element here prevents a rogue mobile device from switching security parameters after the initial negotiation. More information about the information element is given in Chapter 13. The data is not encrypted because the IE was sent in the open during association and is not a secret; however, it is protected by the MIC field and cannot therefore be altered.
    

The fact that the descriptor type field is 1 indicates that the MIC value should be computed using an algorithm called HMAC-MD5, which produces a 16-byte MIC value. The MIC calculation is performed over more the just message (B). It includes all the bytes from the EAPOL protocol version field in the header up to and including the Key Data.

|   |
|---|
|## A Note on HMAC-MD5<br><br>MD5 is a Message Digest algorithm?it takes a message of arbitrary length and produces a 128-bit value called a message digest. It doesn't matter how long the input message is, the digest is always 128 bits. Different input messages could produce the same message digest. However, the algorithm is such that you cannot work in reverse: given a 128-bit digest, you cannot compute a message that would produce that value when processed. Therefore publishing the digest gives nothing away about the message. MD5 is documented in RFC 1321.<br><br>To apply MD-5 to actual messages for the purpose of a MIC, MD-5 is used with Hash Message Authentication Code. HMAC as defined in RFC 2104.<br><br>To compute the MIC, the supplicant needs to use the newly computed temporal keys. In fact this will be the first use of the keys. If the supplicant does not know the correct PMK, it cannot produce a MIC value that will correspond to the expected result. So the MIC in this message achieves two things: It prevents tampering with the message and it proves that the supplicant knows the PMK.|

Show more

##### Message (C): Authenticator![](https://etutorials.org/shared/images/tutorials/tutorial_113/U2192.GIF)Supplicant

When message (B) is received by the authenticator, it is able to extract the value of SNonce because the message is unencrypted. The authenticator then has all the information to compute its copy of the temporal keys. After this is done, the pairwise key distribution is effectively complete. However, the remaining message exchanges, messages (C) and (D), are used to ensure that the keys are put into effect in a synchronized way. Message (C) serves two functions. First, it verifies to the supplicant that the authenticator knows the PMK and is thus a trusted party. Second, it tells the supplicant that the authenticator is ready to install and start using the data encryption keys. The authenticator does not actually install the keys until after it has received message (D). Note that if a retransmission of message (C) is needed due to failure to get a response, the retransmission should be a copy of the original (unencrypted) transmission. The format of message (C) is shown in Table 10.6.

The MIC bit is set and a corresponding MIC value added. The ACK bit is set to indicate a response is required. The value of ANonce is included for reference; although this serves no purpose at this point, it can be used as a check to ensure that this is part of the same four-way handshake.

|   |   |
|---|---|
##### Table 10.6. Message (C) Contents
|Descriptor type|254|
|Key Information|Request, Error: 0<br><br>Secure: 0<br><br>MIC: 1<br><br>Ack: 1<br><br>Install: 0<br><br>Index: 0<br><br>Key type: Pairwise<br><br>Descriptor type: 1|
|Key Length|64|
|Replay Counter|<Current Value>|
|Key Nonce|ANonce|
|EAPOL-Key IV|0|
|RSC|Starting Sequence Number|
|Key Identifier|0|
|Key MIC|MIC Value|
|Key Data Length|Length of Key Data|
|Key Data|Information Element|

Show more

In this message the RSC is used to inform the mobile device of the starting sequence number the access point intends to use. Normally, this would be 0. The Key Data field is used to send a copy of the IE that the access point used in negotiating security during the association phase.

Assuming no retransmit is required, this is the last unencrypted message sent by the authenticator during the life of these pairwise keys. All subsequent messages are encrypted and protected using the temporal data keys.

##### Message (D): Supplicant![](https://etutorials.org/shared/images/tutorials/tutorial_113/U2192.GIF)Authenticator

This final message verifies to the authenticator that the keys are about to be installed. The settings in the message are shown in Table 10.7.

There is nothing surprising or new in the settings for this message, which is similar to message (B) but without the Key Data field. The Secure bit is not set until the four-way handshake has successfully completed and both supplicant and authenticator have installed the keys. This does not happen until message (D) has been received and decoded successfully. Once this has happened, the authenticator is in a position to deliver the group keys. Note that the Key Sequence Start field indicates to the authenticator the sequence number of the first frame the supplicant intends to send.

|   |   |
|---|---|
##### Table 10.7. Message (D) Contents
|Descriptor type|254|
|Key Information|Request, Error: 0<br><br>Secure: 0<br><br>MIC: 1<br><br>Ack: 0<br><br>Install: 1<br><br>Index: 0<br><br>Key type: Pairwise<br><br>Descriptor type: 1|
|Key Length|64|
|Replay Counter|From rcvd Key Message|
|Key Nonce|SNonce|
|EAPOL-Key IV|0|
|RSC|Starting Sequence Number|
|Key Identifier|0|
|Key MIC|MIC Value|
|Key Data Length|0|

Show more

#### Group Key Handshake

After the complexities of the pairwise key exchange, which had to start off with no security in place and build up step by step, the group key delivery is relatively simple. Basically, there are only two messages. The first sends the key and the second acknowledges that the keys are installed. As explained earlier, there is no key synchronization message because the mobile device is able to store more than one group key at a time and the access point can select the key used on a message-by-message basis. Therefore, as long as the access point knows that a new key has been installed, it can start using it at any time in the future; typically, this is after all the other mobile devices have been updated.

The group key is sent in an EAPOL-key message, which we will call message (a). This has the same format as for pairwise keys. However, an important difference is that the Key Data field is used to send the GTK. The fields for the first group key message are shown in Table 10.8.

|   |   |
|---|---|
##### Table 10.8. Group Key Update
|Descriptor type|254|
|Key Information|Request, Error: 0<br><br>Secure: 1<br><br>MIC: 1<br><br>Ack: 1<br><br>Install: 1<br><br>Index: nn<br><br>Key type: Group<br><br>Descriptor type: 1|
|Key Length|32|
|Replay Counter|<Current Value>|
|Key Nonce|GNonce|
|EAPOL-Key IV|IV for encryption of Key Data|
|RSC|Sequence number of the last encrypted group message|
|Key Identifier|0|
|Key MIC|MIC Value|
|Key Data Length|32|
|Key Data|<encrypted GTK>|

Show more

Note that the Secure bit is set because the group key exchange occurs after the pairwise keys are established. The MIC is set (and included) and the ACK bit indicates a reply is required. For the Group Key message the Install bit is set. The Index field is important in the group key message. These two bits indicate which key location should be used to store the new key. For smooth updates, the Key ID index value will not be the value currently in use.

The value of GNonce is included for reference. GNonce is a nonce value selected to derive the GTK from the GMK. The supplicant does not actually need to know this value because the key derivation is done by the access point and not by the mobile device, but it is sent anyway for reference.

Finally, the actual GTK is sent, encrypted with the EAPOL Encryption key that was created as part of the pairwise key handshake. For descriptor type 1, the key is encrypted using RC4 stream cipher[7] after discarding the first 256 bytes of the RC4 cipher stream output. No padding is added so 32 bytes of GTK produces 32 encrypted bytes, which are placed directly into the EAPOL-Key message.

> [7] See Chapter 6 on WEP and Chapter 11 on TKIP for more information on RC4.

When it is filled out, message (a) is sent to the mobile device, which can decrypt the GTK and install it at the appropriate Key ID index. It then replies with an acknowledge message, message (b), which has the same as for pairwise message (D) except that the Secure bit is set and the Type bit indicates Group.

As a last point, it is expected that the group keys will be updated fairly regularly. For example, they should be updated when a mobile device leaves the network. Also they should be updated if a MIC failure occurs when decoding a multicast. Key updates can occur at any time simply by the access point initiating a group key update frame by sending message (a). However, they can also be requested by a mobile device. In this case the mobile device should send message (b) to the access point with the ACK bit set. This causes the access point to create a new GTK and distribute it to every device (one at a time).

![](https://etutorials.org/shared/images/tutorials/tutorial_113/pixel.gif)

